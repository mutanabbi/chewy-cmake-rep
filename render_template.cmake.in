#
# Generate C++ header/implementation/test
#
# ATTENTION DO NOT EDIT! THIS FILE WAS AUTOGENERATED BY CMAKE!
#

if(CMAKE_VERSION VERSION_GREATER 3.2.2)
    cmake_policy(SET CMP0007 NEW)                           # NOTE Sinece(?) CMake 3.2.3 warns if this policy is not set explicitly
endif()

macro(_move_generated_files DSTDIR)
    foreach(_f ${ARGN})
        if(EXISTS "${_f}")
            get_filename_component(_fn "${_f}" NAME)
            if(EXISTS "${DSTDIR}/${_fn}")
                if(_overwrite MATCHES "(y|yes|true|1)")
                    file(REMOVE "${DSTDIR}/${_fn}")
                else()
                    message(FATAL_ERROR "File already exists: ${DSTDIR}/${_fn} and no `overwrite' given")
                endif()
            endif()
            file(RENAME "${_f}" "${DSTDIR}/${_fn}")
            unset(_fn)
        endif()
    endforeach()
endmacro()

# Per project hardcoded data (rendered by define_skeleton_generation_targets() call)
set(_top_srcdir "@CMAKE_CURRENT_SOURCE_DIR@")
set(_top_builddir "@CMAKE_CURRENT_BINARY_DIR@")
set(_template "@_template@")
set(_impl_ext "@SKELETON_IMPL_EXT@")
set(_hdr_ext "@SKELETON_HEADER_EXT@")

# Get some variables from environment. They are here because of
# `make with=param` will pass them...
# class name to generate
set(_class "$ENV{class}")
# subdirectory to put generated files into
set(_subdir "$ENV{subdir}")
# namespaces to put class into
set(_ns "$ENV{ns}")
# want header marker! set `hh=0` to prevent header generation.
set(_hh "$ENV{hh}$ENV{hpp}$ENV{hxx}")
# want implementation marker! set `cc=0` to prevent header generation.
set(_cc "$ENV{cc}$ENV{cpp}$ENV{cxx}")
# make destination directories, if absent
set(_mkdir "$ENV{mkdir}")
set(_md "$ENV{md}")
# overwrite any existed destination file
set(_overwrite "$ENV{overwrite}")

if(_hh MATCHES "([Nn][Oo]|[Oo][Ff][Ff]|false|0)" )
    set(_hh "0")
endif()

if(_cc MATCHES "([Nn][Oo]|[Oo][Ff][Ff]|false|0)" )
    set(_cc "0")
endif()

if(_hh MATCHES "([Yy][Ee][Ss]|[Oo][Nn]|true|1)" )
    set(_hh "1")
endif()

if(_cc MATCHES "([Yy][Ee][Ss]|[Oo][Nn]|true|1)" )
    set(_cc "1")
endif()

# TODO Evaluate other boolean values (e.g. `overwrite` and `mkdir`)?

if(_hh STREQUAL "0" AND _cc STREQUAL "0")
    message(FATAL_ERROR "Why to run this target if you don't need any result?")
endif()

# Transform some parameters
string(REPLACE "::" ";" _ns "${_ns}")
# TODO Transform filename?
set(_filename ${_class}@_filename_suffix@)

# Check mandatory parameters
if(_class STREQUAL "")
    message(FATAL_ERROR "Class name is not provided")
endif()

# If some parameters are ommited, try to guess them...
if(NOT _subdir STREQUAL "")
    if(NOT _ns)
        string(REPLACE "/" ";" _ns "${_subdir}")
    endif()
else()
    if(_ns)
        # Try to guess subdir from namespaces
        foreach(_n ${_ns})
            if(_subdir)
                set(_subdir "${_subdir}/${_n}")
            else()
                set(_subdir "${_n}")
            endif()
        endforeach()
    else()
        message(FATAL_ERROR "`subdir` and/or `ns` parameter(s) must be provided")
    endif()
endif()

# Produce .def file for GNU Autogen
string(REPLACE "/" "__" _guard_base "${_subdir}/${_class}")
string(REGEX REPLACE "[^0-9A-Za-z]" "_" _guard_base "${_guard_base}")
set(_reverse_ns ${_ns})
list(REVERSE _reverse_ns)

set(_def_file "${_top_builddir}/${_filename}.def")

file(
    WRITE "${_def_file}"
    "autogen definitions ${_top_builddir}/${_template};\n"
    "subdir=${_subdir};\n"
    "filename=${_filename};\n"
    "classname=${_class};\n"
    "guard_base=${_guard_base};\n"
    "use_pragma=@USE_PRAGMA_ONCE@;\n"
    "no_license=@NO_LICENSE@;\n"
    "project=@PROJECT_NAME@;\n"
  )
# Form list of namespaces
set(_i 0)
foreach(_n ${_ns})
    file(
        APPEND "${_def_file}"
        "namespace[${_i}]=${_n};\n"
      )
    math(EXPR _i "${_i} + 1")
endforeach()

# Form reverse list of namespaces
set(_i 0)
foreach(_n ${_reverse_ns})
    file(
        APPEND "${_def_file}"
        "reverse_namespace[${_i}]=${_n};\n"
      )
    math(EXPR _i "${_i} + 1")
endforeach()

list(LENGTH _ns _ns_list_size)
string(RANDOM LENGTH ${_ns_list_size} ALPHABET "}" _ns_close)

math(EXPR _ns_close_size "60 - ${_ns_list_size}")
string(RANDOM LENGTH ${_ns_close_size} ALPHABET " " _ns_close_padding)
file(
    APPEND "${_def_file}"
    "ns-close=\"${_ns_close}${_ns_close_padding}\";\n"
  )

# Render new files!
execute_process(
    COMMAND "@AUTOGEN_EXECUTABLE@" -L "${_top_srcdir}" -L "${_top_builddir}" "${_def_file}"
    RESULT_VARIABLE _result
    OUTPUT_VARIABLE _out
    ERROR_VARIABLE _err
  )

if(NOT _result EQUAL "0")
    message(
        FATAL_ERROR "Fail to generate files!\n"
            "GNU Autogen output:\n${_out}\n"
            "GNU Autogen error output:\n${_err}\n"
      )
endif()

set(_dst_dir "${_top_srcdir}/${_subdir}")
set(_dst_hdr "${_dst_dir}/${_filename}.${_hdr_ext}")
set(_dst_impl "${_dst_dir}/${_filename}.${_impl_ext}")
if(NOT "${_top_srcdir}" STREQUAL "${_top_builddir}")
    set(_src_hdr "${_top_builddir}/${_filename}.${_hdr_ext}")
    set(_src_impl "${_top_builddir}/${_filename}.${_impl_ext}")
else()
    set(_src_hdr "${_top_srcdir}/${_filename}.${_hdr_ext}")
    set(_src_impl "${_top_srcdir}/${_filename}.${_impl_ext}")
endif()

if(_hh STREQUAL "0")
    file(REMOVE "${_src_hdr}")
    set(_src_hdr "")
endif()

if(_cc STREQUAL "0")
    file(REMOVE "${_src_impl}")
    set(_src_impl "")
endif()

if(EXISTS "${_dst_dir}")
    _move_generated_files(
        "${_dst_dir}"
        "${_src_hdr}"
        "${_src_impl}"
      )
elseif(_md OR _mkdir)
    file(MAKE_DIRECTORY "${_dst_dir}")
    _move_generated_files(
        "${_dst_dir}"
        "${_src_hdr}"
        "${_src_impl}"
      )
else()
    message(WARNING "Destination directory doesn't exists [${_dst_dir}], leaving generated files at ${_top_builddir}")
endif()

# Cleanup
file(REMOVE "${_def_file}")

# Try to do some post actions
get_filename_component(_this_file "${CMAKE_CURRENT_LIST_FILE}" NAME_WE)
include("${CMAKE_CURRENT_LIST_DIR}/${_this_file}_post.cmake" OPTIONAL)
